package me.RockinChaos.itemjoin.handlers;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.URL;
import java.util.Collection;
import java.util.HashMap;
import java.util.UUID;

import javax.net.ssl.HttpsURLConnection;

import org.bukkit.Bukkit;
import org.bukkit.GameMode;
import org.bukkit.Material;
import org.bukkit.OfflinePlayer;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;
import org.bukkit.inventory.meta.SkullMeta;

import com.mojang.authlib.GameProfile;
import com.mojang.authlib.properties.Property;
import com.mojang.util.UUIDTypeAdapter;

import de.domedd.betternick.BetterNick;
import de.domedd.betternick.api.nickedplayer.NickedPlayer;
import me.RockinChaos.itemjoin.ItemJoin;
import me.RockinChaos.itemjoin.utils.Econ;
import me.RockinChaos.itemjoin.utils.Hooks;
import me.RockinChaos.itemjoin.utils.Reflection;
import net.milkbowl.vault.economy.EconomyResponse;

public class PlayerHandler {
	
	public static boolean cancell = false;
	private static HashMap < String, GameProfile > gameProfiles = new HashMap < String, GameProfile > ();

	@SuppressWarnings("deprecation")
	public static void updateInventory(final Player player) {
        Bukkit.getScheduler().scheduleSyncDelayedTask(ItemJoin.getInstance(), (Runnable)new Runnable() {
            public void run() {
                player.updateInventory();
            }
        }, 1L);
	}
	
	@SuppressWarnings("deprecation")
	public static void delayUpdateInventory(final Player player, final long delay) {
        Bukkit.getScheduler().scheduleSyncDelayedTask(ItemJoin.getInstance(), (Runnable)new Runnable() {
            public void run() {
                player.updateInventory();
            }
        }, delay);
	}
	
	@SuppressWarnings("deprecation")
	public static void setPerfectHandItem(Player player, ItemStack toSet, String type) {
		if (ServerHandler.hasCombatUpdate() && type != null && type.equalsIgnoreCase("HAND")) {
			player.getInventory().setItemInMainHand(toSet);
		} else if (ServerHandler.hasCombatUpdate() && type != null && type.equalsIgnoreCase("OFF_HAND")) {
			player.getInventory().setItemInOffHand(toSet);
		} else if (!ServerHandler.hasCombatUpdate()) {
			player.getInventory().setItemInHand(toSet);
		}
	}
	
	@SuppressWarnings("deprecation")
	public static ItemStack getPerfectHandItem(Player player, String type) {
		if (ServerHandler.hasCombatUpdate() && type != null && type.equalsIgnoreCase("HAND")) {
			return player.getInventory().getItemInMainHand();
		} else if (ServerHandler.hasCombatUpdate() && type != null && type.equalsIgnoreCase("OFF_HAND")) {
			return player.getInventory().getItemInOffHand();
		} else if (!ServerHandler.hasCombatUpdate()) {
			return player.getInventory().getItemInHand();
		}
		return null;
	}
	
	@SuppressWarnings("deprecation")
	public static ItemStack getHandItem(Player player) {
		if (ServerHandler.hasCombatUpdate() && player.getInventory().getItemInMainHand().getType() != null && player.getInventory().getItemInMainHand().getType() != Material.AIR) {
			return player.getInventory().getItemInMainHand();
		} else if (ServerHandler.hasCombatUpdate() && player.getInventory().getItemInOffHand().getType() != null && player.getInventory().getItemInOffHand().getType() != Material.AIR) {
			return player.getInventory().getItemInOffHand();
		} else if (!ServerHandler.hasCombatUpdate()) {
			return player.getInventory().getItemInHand();
		}
		return null;
	}
	
	@SuppressWarnings("deprecation")
	public static ItemStack getMainHandItem(Player player) {
		if (ServerHandler.hasCombatUpdate()) {
			return player.getInventory().getItemInMainHand();
		} if (!ServerHandler.hasCombatUpdate()) {
			return player.getInventory().getItemInHand();
		}
		return null;
	}
	
	@SuppressWarnings("deprecation")
	public static ItemStack getOffHandItem(Player player) {
		if (ServerHandler.hasCombatUpdate()) {
			return player.getInventory().getItemInOffHand();
		} if (!ServerHandler.hasCombatUpdate()) {
			return player.getInventory().getItemInHand();
		}
		return null;
	}
	
	@SuppressWarnings("deprecation")
	public static void setInHandItem(Player player, ItemStack toSet) {
		player.getInventory().setItemInHand(toSet);
	}
	
	public static void setOffhandItem(Player player, ItemStack toSet) {
		if (ServerHandler.hasCombatUpdate()) {
		player.getInventory().setItemInOffHand(toSet);
		}
	}
	
	public static void setMainHandItem(Player player, ItemStack toSet) {
		if (ServerHandler.hasCombatUpdate()) {
		player.getInventory().setItemInMainHand(toSet);
		}
	}
	
	public static boolean isCreativeMode(Player player) {
		final GameMode gamemode = player.getGameMode();
		final GameMode creative = GameMode.CREATIVE;
		if (gamemode == creative) {
			return true;
		}
		return false;
	}
	
	public static boolean isAdventureMode(Player player) {
		final GameMode gamemode = player.getGameMode();
		final GameMode adventure = GameMode.ADVENTURE;
		if (gamemode == adventure) {
			return true;
		}
		return false;
	}
	
	public static boolean getNewSkullMethod() {
		try {
			if (Class.forName("org.bukkit.inventory.meta.SkullMeta").getMethod("getOwningPlayer") != null) {
			return true;
			}
		} catch (Exception e) {}
		return false;
	}
	
	@SuppressWarnings("deprecation")
	public static String getSkullOwner(ItemStack item) {
		if (ServerHandler.hasSpecificUpdate("1_12") && item != null && item.hasItemMeta() && ItemHandler.isSkullTyping(item.getType()) 
				&& ((SkullMeta) item.getItemMeta()).hasOwner() && getNewSkullMethod() != false) {
			String owner =  ((SkullMeta) item.getItemMeta()).getOwningPlayer().getName();
			if (owner != null) { return owner; }
		} else if (item != null && item.hasItemMeta() 
				&& ItemHandler.isSkullTyping(item.getType())
				&& ((SkullMeta) item.getItemMeta()).hasOwner()) {
			String owner = ((SkullMeta) item.getItemMeta()).getOwner();
			if (owner != null) { return owner; }
		} 
		return "NULL";
	}
	
	@SuppressWarnings("deprecation")
	public static ItemMeta setSkullOwner(ItemMeta tempmeta, String owner) {
		if (ServerHandler.hasSpecificUpdate("1_8")) {
        try {
		    Method fetchProfile = Reflection.getOBC("entity.CraftPlayer").getDeclaredMethod("getProfile");
            Field declaredField = tempmeta.getClass().getDeclaredField("profile");
            declaredField.setAccessible(true);
            if (ItemJoin.getInstance().getServer().getPlayer(owner) != null) { declaredField.set(tempmeta, fetchProfile.invoke(ItemJoin.getInstance().getServer().getPlayer(owner))); }
            else if (ItemJoin.getInstance().getServer().getPlayer(owner) == null) {
            	if(gameProfiles.get(owner) == null) {
            	GameProfile profile = new GameProfile(ItemJoin.getInstance().getServer().getOfflinePlayer(owner).getUniqueId(), owner);
            	setSkin(profile, ItemJoin.getInstance().getServer().getOfflinePlayer(owner).getUniqueId());
                gameProfiles.put(owner, profile);
            	}
                declaredField.set(tempmeta, gameProfiles.get(owner));
            }
        } catch (Exception e) { if (ServerHandler.hasDebuggingMode()) { e.printStackTrace(); }}
		} else { 
			if (ServerHandler.hasDebuggingMode()) { 
				ServerHandler.sendDebugMessage("Minecraft does not support offline player heads below Version 1.8."); 
				ServerHandler.sendDebugMessage("Player heads will only be given a skin if the player has previously joined the sever.");
			}
	        SkullMeta skullMeta = (SkullMeta)tempmeta;
	        skullMeta.setOwner(owner);
	        return skullMeta;
	     }
		return tempmeta;
	}
	
	public static boolean setSkin(GameProfile profile, UUID uuid) {
	    try {
	        HttpsURLConnection connection = (HttpsURLConnection) new URL(String.format("https://sessionserver.mojang.com/session/minecraft/profile/%s?unsigned=false", UUIDTypeAdapter.fromUUID(uuid))).openConnection();
	        if (connection.getResponseCode() == HttpsURLConnection.HTTP_OK) {
	            String reply = new BufferedReader(new InputStreamReader(connection.getInputStream())).readLine();
	            String skin = reply.split("\"value\":\"")[1].split("\"")[0];
	            String signature = reply.split("\"signature\":\"")[1].split("\"")[0];
	            profile.getProperties().put("textures", new Property("textures", skin, signature));
	            return true;
	        } else {
	            System.out.println("Connection could not be opened (Response code " + connection.getResponseCode() + ", " + connection.getResponseMessage() + ")");
	            return false;
	        }
	    } catch (IOException e) { if (ServerHandler.hasDebuggingMode()) { e.printStackTrace(); }
	        return false;
	    }
	}
	
	@SuppressWarnings("deprecation")
	public static Player getPlayerString(String player) {
		Player args = null;
		try { args = Bukkit.getPlayer(UUID.fromString(player)); } catch (Exception e) {}
		if (player != null && Hooks.hasBetterNick()) {
			NickedPlayer np = new NickedPlayer(Bukkit.getPlayer(player));
			if (np.isNicked()) {
			return Bukkit.getPlayer(np.getRealName());
			} else {
				return Bukkit.getPlayer(player);
			}
		} else if (args == null) { return Bukkit.getPlayer(player); }
		return args;
	}
	
	public static String getPlayerID(Player player) {
		if (player != null && player.getUniqueId() != null) {
			return player.getUniqueId().toString();
		} else if (player != null && Hooks.hasBetterNick()) {
			NickedPlayer np = new NickedPlayer(player);
			if (np.isNicked()) {
			return np.getRealName();
			} else {
				return player.getName();
			}
		} else if (player != null) {
			return player.getName();
		}
		return "";
	}
	
	public static String getOfflinePlayerID(OfflinePlayer player) {
		if (player != null && player.getUniqueId() != null) {
			return player.getUniqueId().toString();
		} else if (player != null && Hooks.hasBetterNick()) {
			NickedPlayer np = new NickedPlayer((BetterNick) player);
			if (np.isNicked()) {
			return np.getRealName();
			} else {
				return player.getName();
			}
		} else if (player != null) {
			return player.getName();
		}
		return "";
	}
	
	@SuppressWarnings("deprecation")
	public static Player getPlayer(Player player) {
		Player args = null;
		try { args = Bukkit.getPlayer(player.getUniqueId()); } catch (Exception e) {}
		if (player != null && Hooks.hasBetterNick()) {
			NickedPlayer np = new NickedPlayer(player);
			if (np.isNicked()) {
			return Bukkit.getPlayer(np.getRealName());
			} else {
				return Bukkit.getPlayer(player.getName());
			}
		} else if (args == null) { return Bukkit.getPlayer(player.getName()); }
		return args;
	}
	
	public static OfflinePlayer getOfflinePlayer(String playerName) {
		Collection < ? extends OfflinePlayer > playersOnlineNew;
		OfflinePlayer[] playersOnlineOld;
		try {
			if (Bukkit.class.getMethod("getOfflinePlayers", new Class < ? > [0]).getReturnType() == Collection.class) {
				playersOnlineNew = (Collection < ? extends OfflinePlayer > )((Collection < ? > ) Bukkit.class.getMethod("getOfflinePlayers", new Class < ? > [0]).invoke(null, new Object[0]));
				for (OfflinePlayer player: playersOnlineNew) {
					if (player.getName().equalsIgnoreCase(playerName)) {
						return player;
					}
				}
			} else {
				playersOnlineOld = ((OfflinePlayer[]) Bukkit.class.getMethod("getOfflinePlayers", new Class < ? > [0]).invoke(null, new Object[0]));
				for (OfflinePlayer player: playersOnlineOld) {
					if (player.getName().equalsIgnoreCase(playerName)) {
						return player;
					}
				}
			}
		} catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException e) {
			if (ServerHandler.hasDebuggingMode()) { e.printStackTrace(); }
		} 
		
		return null;
	}
	
	@SuppressWarnings("deprecation")
	public static void setItemInHand(Player player, Material mat) {
		player.setItemInHand(new ItemStack(mat));
	}
	
	public static void setItemInOffHand(Player player, Material mat) {
		if (ServerHandler.hasCombatUpdate()) {
		player.getInventory().setItemInOffHand(new ItemStack(mat));
		}
	}
	
	@SuppressWarnings("deprecation")
	public static double getBalance(Player player) {
		double balance = Econ.econ.getBalance(player.getName());
		return balance;
	}
	
	@SuppressWarnings("deprecation")
	public static EconomyResponse withdrawBalance(Player player, int cost) {
		EconomyResponse balance = Econ.econ.withdrawPlayer(player.getName(), cost);;
		return balance;
	}
}
